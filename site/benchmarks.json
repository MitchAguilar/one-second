{"dict.py": {"rounded_iters": 10000000, "code": "#!/usr/bin/env python\n\n# Number to guess: How many entries can\n# we add to a dictionary in a second?\n\nCHUNK_SIZE = 10000\nstrings = [str(i) for i in xrange(CHUNK_SIZE)]\n\ndef f(NUMBER):\n    for i in xrange(NUMBER / CHUNK_SIZE):\n        d = {}\n        for s in strings:\n            d[s] = s\n\nimport sys\nf(int(sys.argv[1]))\n", "exact_iters": 6240873}, "fill_array.c": {"rounded_iters": 1000000000, "code": "#include <stdlib.h>\n\n// Number to guess: How big of an array (in bytes)\n// can we allocate and fill with 5s in a second?\n\nint main(int argc, char **argv) {\n    int NUMBER, i;\n    NUMBER = atoi(argv[1]);\n\n    char* array = malloc(NUMBER);\n    for (i = 0; i < NUMBER; ++i) {\n        array[i] = 5;\n    }\n\n    return 0;\n}\n", "exact_iters": 375950985}, "write_to_memory.py": {"rounded_iters": 1000000000, "code": "#!/usr/bin/env python\n\n# Number to guess: How many bytes can we write\n# to a string in memory in a second?\n\nimport cStringIO\n\nCHUNK_SIZE = 1000000\ns = \"a\" * CHUNK_SIZE\n\ndef f(NUMBER):\n    output = cStringIO.StringIO()\n    bytes_written = 0\n    while bytes_written < NUMBER:\n        output.write(s)\n        bytes_written += CHUNK_SIZE\n\nimport sys\nf(int(sys.argv[1]))\n", "exact_iters": 1427673255}, "json_parse.py": {"rounded_iters": 1000, "code": "#!/usr/bin/env python\n\nimport json\n\n#j = json.dumps({'%d' % (i): i for i in xrange(10000)})\nj = json.dumps(range(10000))\n\ndef f(NUMBER):\n    for _ in xrange(NUMBER):\n        json.loads(j)\n\nimport sys\nf(int(sys.argv[1]))\n", "exact_iters": 966}, "make_one_elt_list.py": {"rounded_iters": 10000000, "code": "#!/usr/bin/env python\n\nimport json\n\ndef f(NUMBER):\n    for i in xrange(NUMBER):\n        [0]\n\nimport sys\nf(int(sys.argv[1]))\n", "exact_iters": 11056092}, "grep_files_and_fail.sh": {"rounded_iters": 1, "code": "#!/bin/bash \n\n# Number to guess: How many files can `grep`\n# search, unsuccessfully, in a second?\n# Note: the file contents will be in the filesystem cache.\n\nNUMBER=$1\n\ngrep -r --files-without-match --binary-files=without-match pandapandapandapanda /usr 2> /dev/null | head -n $NUMBER > /dev/null \n", "exact_iters": 2}, "write_to_disk.py": {"rounded_iters": 1000000000, "code": "#!/usr/bin/env python\n\n# Number to guess: How many bytes can we write\n# to an output file in a second?\n# Note: we make sure everything is sync'd to disk\n# before exiting :)\nimport tempfile\nimport os\n\nCHUNK_SIZE = 1000000\ns = \"a\" * CHUNK_SIZE\n\ndef cleanup(f, name):\n    f.flush()\n    os.fsync(f.fileno())\n    f.close()\n    try:\n        os.remove(name)\n    except:\n        pass\n\ndef f(NUMBER):\n    name = './out'\n    f = open(name, 'w')\n    bytes_written = 0\n    while bytes_written < NUMBER:\n        f.write(s)\n        bytes_written += CHUNK_SIZE\n    cleanup(f, name)\n\nimport sys\nf(int(sys.argv[1]))\n", "exact_iters": 454900693}, "make_empty_list.py": {"rounded_iters": 10000000, "code": "#!/usr/bin/env python\n\nimport json\n\ndef f(NUMBER):\n    for _ in xrange(NUMBER):\n        []\n\nimport sys\nf(int(sys.argv[1]))\n", "exact_iters": 31544333}, "sum.py": {"rounded_iters": 10000000, "code": "#!/usr/bin/env python\n\ndef f(NUMBER):\n    s = 0\n    for i in xrange(NUMBER):\n        s += 1\n\nimport sys\nf(int(sys.argv[1]))\n", "exact_iters": 26069696}, "find-filenames.sh": {"rounded_iters": 100000, "code": "#!/bin/bash\n\n# Number to guess: How many files can `find` list in a second?\n# Note: the files will be in the filesystem cache.\n\nfind / -name '*' 2> /dev/null | head -n $1 > /dev/null\n", "exact_iters": 244279}, "hash.py": {"rounded_iters": 1000000000, "code": "#!/usr/bin/env python\n\n# Number to guess: How many bytes can we md5sum in a second?\n\nimport hashlib\n\nCHUNK_SIZE = 10000\ns = 'a' * CHUNK_SIZE\n\ndef f(NUMBER):\n    bytes_hashed = 0\n    h = hashlib.md5()\n    while bytes_hashed < NUMBER:\n        h.update(s)\n        bytes_hashed += CHUNK_SIZE\n    h.digest()\nimport sys\nf(int(sys.argv[1]))\n", "exact_iters": 454900693}, "run_bin_true.sh": {"rounded_iters": 1000, "code": "#!/bin/bash\n\nNUMBER=$1\n\nfor i in $(seq $NUMBER); do\n    /usr/bin/env true;\ndone\n", "exact_iters": 494}, "bcrypt_hash.py": {"rounded_iters": 1, "code": "#!/usr/bin/env python\n\n# Number to guess: How many passwords\n# can we bcrypt in a second?\n\nimport bcrypt\n\npassword = 'a' * 100\n\ndef f(NUMBER):\n    for _ in xrange(NUMBER):\n        bcrypt.hashpw(password, bcrypt.gensalt())\n        \nimport sys\nf(int(sys.argv[1]))\n", "exact_iters": 3}, "loop.py": {"rounded_iters": 100000000, "code": "#!/usr/bin/env python\n\n# Number to guess: How many iterations of an empty loop can we go through in a second?\n\ndef f(NUMBER):\n    for _ in xrange(NUMBER):\n        pass\n\nimport sys\nf(int(sys.argv[1]))\n", "exact_iters": 46184060}, "run_python.sh": {"rounded_iters": 100, "code": "#!/bin/bash\n\n# Number to guess: How many times can we start\n# the Python interpreter in a second?\n\nNUMBER=$1\n\nfor i in $(seq $NUMBER); do\n    python -c '';\ndone\n", "exact_iters": 63}, "sum.c": {"rounded_iters": 1000000000, "code": "#include <stdlib.h>\n\n// Number to guess: How many iterations of this loop can we go through in a second?\n\nint main(int argc, char **argv) {\n    int NUMBER, i, s;\n    NUMBER = atoi(argv[1]);\n\n    for (s = i = 0; i < NUMBER; ++i) {\n        s += 1;\n    }\n\n    return 0;\n}\n", "exact_iters": 605472824}, "parse_http_request.py": {"rounded_iters": 10000, "code": "#!/usr/bin/env python\n\n# Number to guess: How many HTTP requests\n# can we parse in a second?\n\nfrom BaseHTTPServer import BaseHTTPRequestHandler\nfrom StringIO import StringIO\n\nclass HTTPRequest(BaseHTTPRequestHandler):\n    def __init__(self, request_text):\n        self.rfile = StringIO(request_text)\n        self.raw_requestline = self.rfile.readline()\n        self.error_code = self.error_message = None\n        self.parse_request()\n\n    def send_error(self, code, message):\n        self.error_code = code\n        self.error_message = message\n\nrequest_text = \"\"\"GET / HTTP/1.1\nHost: localhost:8001\nConnection: keep-alive\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.85 Safari/537.36\nAccept-Encoding: gzip, deflate, sdch\nAccept-Language: en-GB,en-US;q=0.8,en;q=0.6\n\"\"\"\n\ndef f(NUMBER):\n    for _ in range(NUMBER):\n        HTTPRequest(request_text)\n\nimport sys\nf(int(sys.argv[1]))\n", "exact_iters": 27276}, "fill_array_out_of_order.c": {"rounded_iters": 100000000, "code": "#include <stdlib.h>\n#include <stdio.h>\n\n// Number to guess: How big of an array (in bytes)\n// can we allocate and fill with 5s in a second?\n// The catch: We do it out of order instead of in order.\nint main(int argc, char **argv) {\n    int NUMBER, i;\n    NUMBER = atoi(argv[1]);\n\n    char* array = malloc(NUMBER);\n    int j = 1;\n    for (i = 0; i < NUMBER; ++i) {\n        j = j * 2;\n        if (j > NUMBER) {\n            j = j - NUMBER;\n        }\n        array[j] = 5;\n    }\n\n    return 0;\n}\n", "exact_iters": 55882714}, "make_four_elt_list.py": {"rounded_iters": 10000000, "code": "#!/usr/bin/env python\n\nimport json\n\ndef f(NUMBER):\n    for _ in xrange(NUMBER):\n        [0,1,2,3]\n\nimport sys\nf(int(sys.argv[1]))\n", "exact_iters": 6240873}, "download_webpage.py": {"rounded_iters": 10, "code": "#!/usr/bin/env python\n\n# Number to guess: How many times can we\n# download google.com in a second?\n\nfrom urllib2 import urlopen\n\n\ndef f(NUMBER):\n    for _ in xrange(NUMBER):\n        r = urlopen(\"http://google.com\")\n        r.read()\n\nimport sys\nf(int(sys.argv[1]))\n", "exact_iters": 6}}